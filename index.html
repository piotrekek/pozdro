<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>made by piotrek &lt;3</title>

<style>
:root{
  --bg:#f6f7fb;--card:#fff;--text:#111;
  --cell:#eef2ff;--cell-sel:#b6ccff;--cell-found:#9fe6a0;
  --tile:46px
}
body.dark{
  --bg:#0f1220;--card:#1a1e35;--text:#f2f4ff;
  --cell:#2a2f55;--cell-sel:#3c4aa8;--cell-found:#2f8f5b;
}
body{font-family:system-ui;background:var(--bg);color:var(--text);padding:20px;transition:.3s}
.layout{display:grid;grid-template-columns:1fr 2fr 1fr;gap:14px}
.card{background:var(--card);border-radius:16px;padding:16px;box-shadow:0 10px 25px rgba(0,0,0,.15)}
.controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px}
button,input,select{padding:10px;border-radius:10px;border:1px solid #ccc}
button{background:#4f7cff;color:#fff;border:none;cursor:pointer}
button.secondary{background:#777}
button.hidden{display:none}
button:disabled{opacity:0.5;cursor:not-allowed}

.board{display:grid;gap:6px;justify-content:center;min-height:200px}
.cell{
  width:var(--tile);height:var(--tile);
  display:flex;align-items:center;justify-content:center;
  font-weight:700;border-radius:10px;
  background:var(--cell);user-select:none;
  transition:.2s;
  opacity:0;
}
.cell.sel{background:var(--cell-sel)}
.cell.found{background:var(--cell-found)}
.cell.show{opacity:1}
.cell.morph{animation:morph .4s ease forwards}
.cell.pulse{animation:pulse 1s infinite}

@keyframes morph{
  0%{transform:scale(.7);filter:hue-rotate(0deg);opacity:0}
  50%{transform:scale(1.15);filter:hue-rotate(180deg);opacity:1}
  100%{transform:scale(1);filter:hue-rotate(360deg);opacity:1}
}
@keyframes pulse{
  0%{transform:scale(1)}
  50%{transform:scale(1.15)}
  100%{transform:scale(1)}
}

.table table{width:100%;border-collapse:collapse}
.table th,.table td{padding:6px;border-bottom:1px solid #555;font-size:13px}

.celebration {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 1000;
  display: none;
}

.cat-emoji {
  position: absolute;
  font-size: 2.5rem;
  animation: float 3s ease-in-out forwards;
  opacity: 0;
}

@keyframes float {
  0% {
    transform: translateY(100vh) rotate(0deg);
    opacity: 1;
  }
  50% {
    opacity: 1;
  }
  100% {
    transform: translateY(-100px) rotate(360deg);
    opacity: 0;
  }
}

.record-message {
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
  color: white;
  padding: 15px 25px;
  border-radius: 15px;
  font-weight: bold;
  font-size: 1.2rem;
  text-align: center;
  margin-top: 15px;
  animation: rainbow 2s infinite;
  display: none;
}

.cooldown-timer {
  color: #ff6b6b;
  font-weight: bold;
  font-size: 0.9rem;
  margin-top: 8px;
  text-align: center;
  display: none;
}

@keyframes rainbow {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

@media(max-width:900px){.layout{grid-template-columns:1fr}}
</style>
</head>

<body>
<h1>spoko giera</h1>

<div class="card controls">
  <input id="nick" placeholder="Tw√≥j nick">
  <select id="level">
    <option value="7">7√ó7</option>
    <option value="12">12√ó12</option>
    <option value="15">15√ó15</option>
  </select>
  <button id="start">Rozpocznij</button>
  <button id="giveup" class="secondary hidden">Poddaj siƒô</button>
  <button id="theme" class="secondary">üåô</button>
  <div id="cooldownTimer" class="cooldown-timer"></div>
</div>

<div class="layout">
  <div class="card">
    <h3>üìú Zasady</h3>
    <ul>
      <li>Jedno ukryte s≈Çowo</li>
      <li>Poziom / pion / przekƒÖtna</li>
      <li>S≈Çowo mo≈ºe byƒá wspak</li>
    </ul>
    <div id="hardestWord" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee;">
      <h4>üèÜ Najtrudniejsze s≈Çowo</h4>
      <div id="hardestWordDisplay" style="font-size: 1.1rem; font-weight: bold; color: #ff6b6b; margin-top: 10px;">
        ≈Åadujƒô...
      </div>
    </div>
  </div>

  <div class="card">
    <div id="board" class="board"></div>
    <div id="status"></div>
    <div id="recordMessage" class="record-message"></div>
  </div>

  <div class="card table">
    <h3>üèÜ Ranking <span id="lvlLabel"></span></h3>
    <table id="scores">
      <tr><th>Nick</th><th>Czas (s)</th></tr>
    </table>
  </div>
</div>

<div id="celebration" class="celebration"></div>

<script>
// =============== NOWA LISTA S≈Å√ìW ===============
const WORDS=["KOBYLNIK","RENZ","≈öLƒÑSKA","≈ÅATA","ƒÜWIK","GRYSA","MATYSIAK","SZCZEPANIAK","KABACI≈ÉSKA","GƒÑGA≈ÅA","GRAL","KOWALCZYK","ORWAT","AUGUSTYNIAK","WASILEWSKI","GELLERT","BADOWSKA","BALCEREK","RATAJCZAK","GNI≈ÅKA","TOMCZAK","SIEK","SZARZEWSKI","KOPYCHYN","O≈ªA≈ÉSKA"];
const LETTERS="AƒÑBCƒÜDEƒòFGHIJKL≈ÅMN≈ÉO√ìPRS≈öTUVWXYZ≈π≈ª";
const CAT_EMOJIS = ["üò∫", "üò∏", "üòπ", "üòª", "üòº", "üòΩ", "üôÄ", "üòø", "üòæ", "üê±"];

// =============== KONFIGURACJA JSONBIN ===============
const JSONBIN_BIN_ID = "697bcee243b1c97be955c919";
const JSONBIN_STATS_BIN_ID = "697bd2b6d0ea881f40913cce";
const JSONBIN_API_KEY = "$2a$10$Poka03qXK.rnNNTaGYW/zOLzQlBUuKiGlPxjSxYaKCKc1AV6c04We";

const boardEl=document.getElementById('board');
const statusEl=document.getElementById('status');
const scoresEl=document.getElementById('scores');
const startBtn=document.getElementById('start');
const giveupBtn=document.getElementById('giveup');
const levelEl=document.getElementById('level');
const lvlLabel=document.getElementById('lvlLabel');
const nickInput=document.getElementById('nick');
const themeBtn=document.getElementById('theme');
const celebrationEl=document.getElementById('celebration');
const recordMessageEl=document.getElementById('recordMessage');
const hardestWordDisplay=document.getElementById('hardestWordDisplay');
const cooldownTimerEl=document.getElementById('cooldownTimer');

let grid=[],size=7,target="",path=[],selecting=false,startTime=0;
let solution=[];
let gameActive=false;
let currentDirection=null;
let giveupCooldown = 0;
let cooldownInterval = null;
let gameStartTime = 0;
let gameCooldownActive = false;
let isOnline = true; // Flaga czy jest po≈ÇƒÖczenie z internetem

// =============== INICJALIZACJA ===============
// Inicjalizacja lokalnych statystyk
if(!localStorage.getItem('giveupStats')) {
  const initialStats = {};
  WORDS.forEach(word => {
    initialStats[word] = 0;
  });
  localStorage.setItem('giveupStats', JSON.stringify(initialStats));
}

if(localStorage.theme==='dark')document.body.classList.add('dark');
themeBtn.onclick=()=>{
  document.body.classList.toggle('dark');
  localStorage.theme=document.body.classList.contains('dark')?'dark':'light';
  themeBtn.textContent=document.body.classList.contains('dark')?'‚òÄÔ∏è':'üåô';
};

startBtn.onclick=startGame;
levelEl.onchange=renderScores;

// =============== G≈Å√ìWNE FUNKCJE GRY ===============
function startGame() {
  if(!nickInput.value.trim()){
    alert("Podaj nick");
    return;
  }
  
  // NIE blokuj przycisku - to powoduje zawieszanie!
  
  if(gameCooldownActive) {
    const timeLeft = 5 - Math.floor((Date.now() - gameStartTime) / 1000);
    if(timeLeft > 0) {
      statusEl.textContent = `Poczekaj ${timeLeft}s przed nowƒÖ grƒÖ`;
      return;
    }
  }
  
  size=+levelEl.value;
  lvlLabel.textContent=size+"√ó"+size;

  startBtn.classList.add('hidden');
  giveupBtn.classList.remove('hidden');
  gameActive=true;
  currentDirection=null;
  recordMessageEl.style.display = 'none';
  giveupBtn.disabled = true;
  giveupBtn.textContent = "Poddaj siƒô (5s)";
  cooldownTimerEl.style.display = 'block';
  
  giveupCooldown = 5;
  updateGiveupButton();
  
  if(cooldownInterval) clearInterval(cooldownInterval);
  cooldownInterval = setInterval(() => {
    giveupCooldown--;
    updateGiveupButton();
    
    if(giveupCooldown <= 0) {
      clearInterval(cooldownInterval);
      cooldownInterval = null;
      giveupBtn.disabled = false;
      giveupBtn.textContent = "Poddaj siƒô";
      cooldownTimerEl.style.display = 'none';
    }
  }, 1000);

  prepareNewGrid();
  
  if(boardEl.children.length>0){
    boardEl.innerHTML='';
  }
  
  draw();
  
  setTimeout(()=>{
    animateBoardStart();
    startTime=Date.now();
    statusEl.textContent="Znajd≈∫ ukryte s≈Çowo!";
  }, 50);
}

function updateGiveupButton() {
  if(giveupCooldown > 0) {
    giveupBtn.textContent = `Poddaj siƒô (${giveupCooldown}s)`;
    cooldownTimerEl.textContent = `Mo≈ºesz siƒô poddaƒá za: ${giveupCooldown}s`;
  }
}

function animateBoardStart(){
  const cells=[...boardEl.children];
  const step=40;
  const centerX=Math.floor(size/2);
  const centerY=Math.floor(size/2);
  
  cells.forEach(cell=>{
    const r=+cell.dataset.r;
    const c=+cell.dataset.c;
    
    const distance=Math.sqrt(Math.pow(r-centerY,2)+Math.pow(c-centerX,2));
    const delay=distance*step;
    
    cell.textContent=grid[r][c];
    
    setTimeout(()=>{
      cell.classList.add('morph');
      
      cell.addEventListener('animationend',function handler(){
        cell.classList.remove('morph');
        cell.classList.add('show');
        cell.removeEventListener('animationend',handler);
      }, {once: true});
    }, delay);
  });
}

function prepareNewGrid(){
  grid=[...Array(size)].map(()=>Array(size).fill(''));
  target=WORDS[Math.floor(Math.random()*WORDS.length)];
  solution=[];
  placeWord();
  fill();
}

function placeWord(){
  const dirs=[[1,0],[0,1],[1,1],[-1,0],[0,-1],[-1,-1],[1,-1],[-1,1]];
  const [dx,dy]=dirs[Math.floor(Math.random()*dirs.length)];
  const w=Math.random()<.5?target:[...target].reverse().join('');
  let r,c;
  do{
    r=rand(size);
    c=rand(size);
  }while(r+dy*(w.length-1)<0||r+dy*(w.length-1)>=size||
        c+dx*(w.length-1)<0||c+dx*(w.length-1)>=size);
  
  for(let i=0;i<w.length;i++){
    const rr=r+dy*i;
    const cc=c+dx*i;
    grid[rr][cc]=w[i];
    solution.push([rr,cc]);
  }
}

function fill(){
  for(let r=0;r<size;r++){
    for(let c=0;c<size;c++){
      if(!grid[r][c]){
        grid[r][c]=LETTERS[rand(LETTERS.length)];
      }
    }
  }
}

function draw(){
  boardEl.style.gridTemplateColumns=`repeat(${size},var(--tile))`;
  boardEl.innerHTML='';
  
  for(let r=0;r<size;r++){
    for(let c=0;c<size;c++){
      const cell=document.createElement('div');
      cell.className='cell';
      cell.dataset.r=r;
      cell.dataset.c=c;
      
      cell.onpointerdown=()=>startSel(cell);
      cell.onpointerenter=()=>moveSel(cell);
      
      boardEl.appendChild(cell);
    }
  }
  
  document.onpointerup=endSel;
}

function startSel(cell){
  if(!gameActive || cell.classList.contains('found')) return;
  selecting=true;
  path=[cell];
  currentDirection=null;
  cell.classList.add('sel');
}

function moveSel(cell){
  if(!selecting || !gameActive || cell.classList.contains('found')) return;
  if(path.includes(cell)) return;
  
  const last=path[path.length-1];
  const dr=+cell.dataset.r - +last.dataset.r;
  const dc=+cell.dataset.c - +last.dataset.c;
  
  if(Math.abs(dr) > 1 || Math.abs(dc) > 1) return;
  if(dr !== 0 && dc !== 0 && Math.abs(dr) !== Math.abs(dc)) return;
  
  if(path.length === 1) {
    if(dr === 0 && dc !== 0) currentDirection = 'horizontal';
    else if(dc === 0 && dr !== 0) currentDirection = 'vertical';
    else if(Math.abs(dr) === Math.abs(dc)) currentDirection = 'diagonal';
  } else {
    const first = path[0];
    const second = path[1];
    const firstDr = +second.dataset.r - +first.dataset.r;
    const firstDc = +second.dataset.c - +first.dataset.c;
    
    if(firstDr === 0) {
      if(dr !== 0) return;
    } else if(firstDc === 0) {
      if(dc !== 0) return;
    } else {
      if(Math.abs(dr) !== Math.abs(dc)) return;
      if(Math.sign(dr) !== Math.sign(firstDr) || Math.sign(dc) !== Math.sign(firstDc)) return;
    }
  }
  
  path.push(cell);
  cell.classList.add('sel');
}

function endSel(){
  if(!selecting || !gameActive) return;
  selecting=false;
  
  const selectedWord=path.map(cell=>cell.textContent).join('');
  const reversedWord=[...selectedWord].reverse().join('');
  
  if(selectedWord===target || reversedWord===target){
    path.forEach(cell=>{
      cell.classList.remove('sel');
      cell.classList.add('found');
    });
    finish();
  }else{
    path.forEach(cell=>cell.classList.remove('sel'));
  }
  
  path=[];
  currentDirection=null;
}

function finish(){
  gameActive=false;
  const time=((Date.now()-startTime)/1000).toFixed(2);
  statusEl.textContent=`Gratulacje! Znaleziono s≈Çowo w ${time}s`;
  
  // Dodaj wynik lokalnie (SYNCHRONICZNIE)
  addScoreLocal(nickInput.value.trim(), time);
  
  // Spr√≥buj wys≈Çaƒá do serwera (ASYNCHRONICZNIE)
  sendScoreToServer(nickInput.value.trim(), time);
  
  gameCooldownActive = true;
  gameStartTime = Date.now();
  
  startBtn.classList.remove('hidden');
  giveupBtn.classList.add('hidden');
  
  if(cooldownInterval) {
    clearInterval(cooldownInterval);
    cooldownInterval = null;
  }
}

// =============== PROSTE FUNKCJE DLA JSONBIN ===============
// Funkcja do wysy≈Çania wynik√≥w (NIE BLOKUJƒÑCA)
function sendScoreToServer(nick, time) {
  if (!isOnline) return; // Je≈õli offline, nie pr√≥buj
  
  // U≈ºyj setTimeout aby nie blokowaƒá UI
  setTimeout(async () => {
    try {
      const currentSize = size;
      const normalizedNick = nick.toLowerCase().trim();
      
      // 1. Pobierz aktualne wyniki
      const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}/latest`, {
        headers: {
          'X-Master-Key': JSONBIN_API_KEY,
          'Content-Type': 'application/json'
        }
      });
      
      if (!response.ok) {
        isOnline = false;
        return;
      }
      
      const data = await response.json();
      const allScores = data.record || { "7": [], "12": [], "15": [] };
      
      // 2. Dodaj nowy wynik
      if (!allScores[currentSize]) {
        allScores[currentSize] = [];
      }
      
      allScores[currentSize] = allScores[currentSize].filter(
        score => score.nick.toLowerCase().trim() !== normalizedNick
      );
      
      allScores[currentSize].push({
        nick: nick.trim(),
        time: +time,
        date: new Date().toISOString()
      });
      
      allScores[currentSize].sort((a, b) => a.time - b.time);
      allScores[currentSize] = allScores[currentSize].slice(0, 10);
      
      // 3. Wy≈õlij z powrotem
      await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`, {
        method: 'PUT',
        headers: {
          'X-Master-Key': JSONBIN_API_KEY,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(allScores)
      });
      
      isOnline = true;
    } catch (error) {
      isOnline = false;
      // Cicho ignoruj b≈ÇƒÖd - nie blokuj gry
    }
  }, 0); // setTimeout 0 = asynchronicznie, po zako≈Ñczeniu bie≈ºƒÖcego taska
}

// Funkcja do wysy≈Çania statystyk podda≈Ñ
function sendGiveupStatToServer(targetWord) {
  if (!isOnline) return;
  
  setTimeout(async () => {
    try {
      const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_STATS_BIN_ID}/latest`, {
        headers: {
          'X-Master-Key': JSONBIN_API_KEY,
          'Content-Type': 'application/json'
        }
      });
      
      if (!response.ok) {
        isOnline = false;
        return;
      }
      
      const data = await response.json();
      const globalStats = data.record || {};
      
      if (!globalStats[targetWord]) {
        globalStats[targetWord] = 1;
      } else {
        globalStats[targetWord] += 1;
      }
      
      await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_STATS_BIN_ID}`, {
        method: 'PUT',
        headers: {
          'X-Master-Key': JSONBIN_API_KEY,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(globalStats)
      });
      
      isOnline = true;
    } catch (error) {
      isOnline = false;
    }
  }, 0);
}

// =============== LOKALNE FUNKCJE (NIGDY NIE ZAWIESZAJƒÑ) ===============
function addScoreLocal(nick, time){
  const currentSize = size;
  const key = 'scores_' + currentSize;
  let scores = JSON.parse(localStorage.getItem(key) || '[]');
  
  const normalizedNick = nick.toLowerCase().trim();
  scores = scores.filter(score => score.nick.toLowerCase().trim() !== normalizedNick);
  
  const oldBestTime = scores.length > 0 ? scores[0].time : Infinity;
  const isNewRecord = scores.length === 0 || +time < oldBestTime;
  
  scores.push({
    nick: nick.trim(),
    time: +time,
    date: new Date().toISOString()
  });
  
  scores.sort((a,b) => a.time - b.time);
  const topScores = scores.slice(0,10);
  localStorage.setItem(key, JSON.stringify(topScores));
  
  renderScores();
  
  if(isNewRecord) {
    celebrateRecord(nick, time);
  }
}

function celebrateRecord(nick, time) {
  recordMessageEl.textContent = `üèÜ ${nick} ustanowi≈Çe≈õ rekord! ${time}s üèÜ`;
  recordMessageEl.style.display = 'block';
  
  celebrationEl.style.display = 'block';
  celebrationEl.innerHTML = '';
  
  for(let i = 0; i < 20; i++) {
    const cat = document.createElement('div');
    cat.className = 'cat-emoji';
    cat.textContent = CAT_EMOJIS[Math.floor(Math.random() * CAT_EMOJIS.length)];
    
    const startX = Math.random() * window.innerWidth;
    cat.style.left = startX + 'px';
    
    const delay = Math.random() * 1000;
    cat.style.animationDelay = delay + 'ms';
    
    const duration = 2 + Math.random() * 2;
    cat.style.animationDuration = duration + 's';
    
    celebrationEl.appendChild(cat);
  }
  
  setTimeout(() => {
    celebrationEl.style.display = 'none';
    celebrationEl.innerHTML = '';
  }, 3000);
}

// =============== FUNKCJA PODDAWANIA SIƒò ===============
giveupBtn.onclick=function(){
  if(giveupCooldown > 0) return;
  
  gameActive=false;
  
  // 1. Zaktualizuj lokalne statystyki (SYNCHRONICZNIE)
  const giveupStats = JSON.parse(localStorage.getItem('giveupStats'));
  giveupStats[target] = (giveupStats[target] || 0) + 1;
  localStorage.setItem('giveupStats', JSON.stringify(giveupStats));
  
  // 2. Wy≈õlij do serwera (ASYNCHRONICZNIE - nie blokuje)
  sendGiveupStatToServer(target);
  
  // 3. Natychmiastowa aktualizacja UI
  updateHardestWordDisplay();
  
  const cells=[...boardEl.children];
  solution.forEach(([r,c], index)=>{
    setTimeout(()=>{
      const cell=cells.find(e=>+e.dataset.r===r&&+e.dataset.c===c);
      if(cell){
        cell.classList.remove('sel');
        cell.classList.add('found','pulse');
      }
    }, index*100);
  });
  
  statusEl.textContent=`S≈Çowo to: ${target}`;
  
  gameCooldownActive = true;
  gameStartTime = Date.now();
  
  startBtn.classList.remove('hidden');
  giveupBtn.classList.add('hidden');
  
  if(cooldownInterval) {
    clearInterval(cooldownInterval);
    cooldownInterval = null;
  }
};

// =============== FUNKCJE WY≈öWIETLANIA ===============
async function updateHardestWordDisplay() {
  // Najpierw poka≈º lokalne dane (natychmiast)
  const giveupStats = JSON.parse(localStorage.getItem('giveupStats'));
  const statsArray = Object.entries(giveupStats);
  
  if(statsArray.length > 0) {
    let hardestWord = '';
    let maxCount = 0;
    
    statsArray.forEach(([word, count]) => {
      if(count > maxCount) {
        maxCount = count;
        hardestWord = word;
      }
    });
    
    if(hardestWord && maxCount > 0) {
      hardestWordDisplay.innerHTML = `
        <div style="text-align: center;">
          <div style="font-size: 1.3rem; color: #ff6b6b;">${hardestWord}</div>
          <div style="font-size: 0.9rem; color: #666; margin-top: 5px;">
            Lokalnych podda≈Ñ: ${maxCount}
          </div>
          <div style="font-size: 0.7rem; color: #888; margin-top: 3px;">
            ‚ö†Ô∏è Tylko dane lokalne
          </div>
        </div>
      `;
    }
  }
  
  // Potem spr√≥buj pobraƒá globalne dane (asynchronicznie)
  if (isOnline) {
    setTimeout(async () => {
      try {
        const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_STATS_BIN_ID}/latest`, {
          headers: {
            'X-Master-Key': JSONBIN_API_KEY
          }
        });
        
        if (!response.ok) {
          isOnline = false;
          return;
        }
        
        const data = await response.json();
        const globalStats = data.record || {};
        
        let hardestWord = '';
        let maxCount = 0;
        
        Object.entries(globalStats).forEach(([word, count]) => {
          if (count > maxCount) {
            maxCount = count;
            hardestWord = word;
          }
        });
        
        if (hardestWord && maxCount > 0) {
          hardestWordDisplay.innerHTML = `
            <div style="text-align: center;">
              <div style="font-size: 1.3rem; color: #ff6b6b;">${hardestWord}</div>
              <div style="font-size: 0.9rem; color: #666; margin-top: 5px;">
                Globalnych podda≈Ñ: ${maxCount}
              </div>
              <div style="font-size: 0.7rem; color: #888; margin-top: 3px;">
                üü¢ Dane globalne
              </div>
            </div>
          `;
        }
        
        isOnline = true;
      } catch (error) {
        isOnline = false;
      }
    }, 0);
  }
}

async function renderScores(){
  const selectedSize = levelEl.value;
  lvlLabel.textContent = selectedSize + "√ó" + selectedSize;
  
  scoresEl.innerHTML = '<tr><th>Nick</th><th>Czas (s)</th></tr>';
  
  // Najpierw poka≈º lokalne wyniki (natychmiast)
  const key = 'scores_' + selectedSize;
  const localScores = JSON.parse(localStorage.getItem(key) || '[]');
  
  if(localScores.length === 0){
    scoresEl.innerHTML += '<tr><td colspan="2" style="text-align:center;padding:10px;">Brak wynik√≥w</td></tr>';
  } else {
    localScores.forEach(score => {
      scoresEl.innerHTML += `
        <tr>
          <td>${score.nick}</td>
          <td>${score.time}</td>
        </tr>
      `;
    });
  }
  
  // Potem spr√≥buj pobraƒá globalne (asynchronicznie)
  if (isOnline) {
    setTimeout(async () => {
      try {
        const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}/latest`, {
          headers: {
            'X-Master-Key': JSONBIN_API_KEY
          }
        });
        
        if (!response.ok) {
          isOnline = false;
          return;
        }
        
        const data = await response.json();
        const serverScores = data.record[selectedSize] || [];
        
        if (serverScores.length > 0) {
          scoresEl.innerHTML = '<tr><th>Nick</th><th>Czas (s)</th></tr>';
          
          const allScores = [...serverScores, ...localScores];
          const uniqueScores = [];
          const seen = new Set();
          
          allScores.forEach(score => {
            const scoreKey = score.nick.toLowerCase() + '-' + score.time;
            if (!seen.has(scoreKey)) {
              seen.add(scoreKey);
              uniqueScores.push(score);
            }
          });
          
          uniqueScores.sort((a, b) => a.time - b.time);
          
          uniqueScores.slice(0, 10).forEach(score => {
            scoresEl.innerHTML += `
              <tr>
                <td>${score.nick}</td>
                <td>${score.time.toFixed(2)}</td>
              </tr>
            `;
          });
          
          const infoRow = document.createElement('tr');
          infoRow.innerHTML = `<td colspan="2" style="text-align:center;font-size:0.8em;color:#777;padding-top:10px;">
            üü¢ Ranking globalny
          </td>`;
          scoresEl.appendChild(infoRow);
        }
        
        isOnline = true;
      } catch (error) {
        isOnline = false;
      }
    }, 0);
  }
}

function rand(n){
  return Math.floor(Math.random()*n);
}

// Sprawdzanie cooldownu przed nowƒÖ grƒÖ co sekundƒô
setInterval(() => {
  if(gameCooldownActive) {
    const timePassed = Math.floor((Date.now() - gameStartTime) / 1000);
    if(timePassed >= 5) {
      gameCooldownActive = false;
    }
  }
}, 1000);

// Inicjalizacja
renderScores();
updateHardestWordDisplay();
</script>
</body>
</html>